<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nova Sonic WebSocket Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
            margin: 0;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        
        .header-text {
            text-align: left;
        }
        
        .header h1 {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 0;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .header p {
            display: none;
        }
        
        .content {
            padding: 10px 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        #status { 
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 10px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            min-width: 100px;
            text-align: center;
        }
        
        .connected { 
            background: rgba(129, 199, 132, 0.95);
            color: white;
        }
        
        .disconnected { 
            background: rgba(229, 115, 115, 0.95);
            color: white;
        }
        
        #controls { 
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            max-width: 200px;
        }
        
        button { 
            flex: 1;
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 1px 4px rgba(0,0,0,0.15);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #toggleBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        #toggleBtn.connected {
            background: linear-gradient(135deg, #e57373 0%, #ef5350 100%);
        }
        
        .config-section {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }
        
        .form-group {
            margin-bottom: 0;
            flex: 1;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 2px;
            font-weight: 600;
            color: #333;
            font-size: 10px;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 11px;
            transition: all 0.3s ease;
            font-family: inherit;
            background: white;
        }
        
        .form-group small {
            display: none;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        #textInput {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 12px;
            transition: all 0.3s ease;
            font-family: inherit;
        }
        
        #textInput:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }
        
        #textInput:disabled {
            background: #f5f5f5;
            cursor: not-allowed;
        }
        
        #sendBtn {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            padding: 6px 16px;
            flex: 0 0 auto;
        }
        
        .panels-container { 
            display: flex;
            gap: 15px;
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }
        
        .panel { 
            flex: 1;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .panel h2 { 
            margin: 0;
            padding: 6px 10px;
            font-size: 12px;
            font-weight: 700;
            color: white;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-bottom: none;
            flex-shrink: 0;
        }
        
        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            flex-shrink: 0;
        }
        
        .event-filter {
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .event-filter input {
            width: 100%;
            padding: 4px 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 11px;
            font-family: inherit;
        }
        
        .event-filter input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .event-filter input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }
        
        .event.hidden {
            display: none;
        }
        
        #messages { 
            height: 0;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 10px;
            background: #fafafa;
        }
        
        #messages::-webkit-scrollbar,
        #events::-webkit-scrollbar {
            width: 8px;
        }
        
        #messages::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        #messages::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }
        
        .message { 
            margin: 4px 0;
            padding: 6px 10px;
            border-radius: 10px;
            max-width: 80%;
            animation: slideIn 0.3s ease;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            font-size: 12px;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .user { 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            margin-left: auto;
            text-align: right;
        }
        
        .assistant { 
            background: white;
            border: 2px solid #e0e0e0;
            color: #333;
        }
        
        .system { 
            background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%);
            color: #f57f17;
            font-style: italic;
            text-align: center;
            margin: 10px auto;
            max-width: 60%;
            font-size: 12px;
        }
        
        .tool { 
            background: linear-gradient(135deg, #c8e6c9 0%, #a5d6a7 100%);
            color: #2e7d32;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        #events { 
            height: 0;
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px;
            background: #1e1e1e;
            font-family: 'SF Mono', 'Monaco', 'Courier New', monospace;
            font-size: 10px;
        }
        
        #events::-webkit-scrollbar-track {
            background: #2d2d2d;
        }
        
        #events::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }
        
        .event { 
            margin: 3px 0;
            padding: 5px 8px;
            border-left: 2px solid #667eea;
            background: #2d2d2d;
            color: #d4d4d4;
            border-radius: 3px;
            animation: slideIn 0.2s ease;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .event::-webkit-scrollbar {
            width: 6px;
        }
        
        .event::-webkit-scrollbar-track {
            background: #1e1e1e;
            border-radius: 3px;
        }
        
        .event::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 3px;
        }
        
        .event::-webkit-scrollbar-thumb:hover {
            background: #7e8ef0;
        }
        
        .event.sent { 
            border-left-color: #4caf50;
            background: #1a2e1a;
        }
        
        .event.received { 
            border-left-color: #2196f3;
            background: #1a2533;
        }
        
        .event-type { 
            color: #ffa726;
            font-weight: bold;
            font-size: 10px;
            margin-bottom: 2px;
        }
        
        .event-time { 
            color: #9e9e9e;
            font-size: 8px;
            margin-bottom: 2px;
        }
        
        .event-data { 
            color: #81c784;
            margin-top: 2px;
            white-space: pre-wrap;
            word-break: break-all;
            line-height: 1.3;
            font-size: 9px;
        }
        
        .text-input-section {
            padding: 10px;
            border-top: 1px solid #e0e0e0;
            background: #f8f9fa;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-text">
                <h1>üéôÔ∏è Nova Sonic S2S WebSocket Client - with Bedrock AgentCore</h1>
            </div>
            <div id="status" class="disconnected">Disconnected</div>
        </div>
        
        <div class="content">
            <div class="config-section">
                <div class="form-group">
                    <label for="websocketUrl">üîó WebSocket URL</label>
                    <input style="display:none" type="text" id="websocketUrl" placeholder="ws://localhost:8081/ws" value="ws://localhost:8081/ws">
                    <!-- <small style="color: #666; font-size: 12px; margin-top: 4px; display: block;">
                        Enter the WebSocket server URL (default: ws://localhost:8081/ws)
                    </small> -->
                </div>
                <div class="form-group">
                    <label for="voiceSelect">üé§ Voice</label>
                    <select id="voiceSelect" onchange="changeVoice()">
                        <optgroup label="üá∫üá∏üá¨üáßüá¶üá∫ English">
                            <option value="tiffany">Tiffany (US, Female, Polyglot)</option>
                            <option value="matthew" selected>Matthew (US, Male)</option>
                            <option value="amy">Amy (UK, Female)</option>
                            <option value="olivia">Olivia (AU, Female)</option>
                        </optgroup>
                        <optgroup label="üá´üá∑ French">
                            <option value="florian">Florian (FR, Male, Polyglot)</option>
                            <option value="ambre">Ambre (FR, Female, Polyglot)</option>
                        </optgroup>
                        <optgroup label="üáÆüáπ Italian">
                            <option value="lorenzo">Lorenzo (IT, Male, Polyglot)</option>
                            <option value="beatrice">Beatrice (IT, Female, Polyglot)</option>
                        </optgroup>
                        <optgroup label="üá©üá™ German">
                            <option value="lennart">Lennart (DE, Male, Polyglot)</option>
                            <option value="greta">Greta (DE, Female, Polyglot)</option>
                        </optgroup>
                        <optgroup label="üá™üá∏üá∫üá∏ Spanish">
                            <option value="carlos">Carlos (US/ES, Male, Polyglot)</option>
                            <option value="lupe">Lupe (US/ES, Female, Polyglot)</option>
                        </optgroup>
                    </select>
                </div>
            </div>
            
            <div id="controls">
                <button id="toggleBtn" onclick="toggleConnection()">üöÄ Start Conversation</button>
            </div>
            
            <div class="panels-container">
                <div class="panel">
                    <h2>üí¨ Conversation</h2>
                    <div id="messages"></div>
                    <div class="text-input-section">
                        <div class="input-group">
                            <input type="text" id="textInput" placeholder="Type your message here..." disabled>
                            <button id="sendBtn" onclick="sendTextMessage()" disabled>Send</button>
                        </div>
                    </div>
                </div>
                <div class="panel">
                    <div class="panel-header">
                        <h2>üì° Raw Events</h2>
                        <div class="event-filter">
                            <input type="text" id="eventFilter" placeholder="üîç Filter events by keyword..." oninput="filterEvents()" />
                        </div>
                    </div>
                    <div id="events"></div>
                </div>
            </div>
        </div>
    </div>
    <script>
        let ws = null;
        let audioContext = null;
        let isRecording = false;
        let audioPlaybackContext = null;
        let nextPlayTime = 0;
        let promptName = null;
        let audioContentName = null;
        let textContentName = null;
        let currentGenerationStage = null;  // Track generation stage from contentStart
        let sessionStarted = false;  // Track if session has been started
        let activeAudioSources = [];  // Track active audio sources for interruption
        let isInterrupted = false;  // Track if we're in an interrupted state
        
        // Transcript buffering for smoother display
        let transcriptBuffer = {
            user: { text: '', timer: null, element: null },
            assistant: { text: '', timer: null, element: null }
        };
        const TRANSCRIPT_BUFFER_DELAY = 1000; // 1 second delay before finalizing
        
        function handleBufferedTranscript(role, text) {
            // Validate role to prevent issues
            const allowedRoles = ['user', 'assistant'];
            if (!allowedRoles.includes(role)) {
                console.warn(`Invalid role: ${role}`);
                return;
            }
            
            const buffer = transcriptBuffer[role];
            
            // Clear existing timer
            if (buffer.timer) {
                clearTimeout(buffer.timer);
            }
            
            // Append new text
            buffer.text += (buffer.text ? ' ' : '') + text;
            
            // Update or create message element
            if (buffer.element && buffer.element.parentNode) {
                // Update existing message
                const prefix = role === 'user' ? 'üé§ User' : 'üîä Assistant';
                buffer.element.textContent = `${prefix}: ${buffer.text}`;
            } else {
                // Create new message
                const prefix = role === 'user' ? 'üé§ User' : 'üîä Assistant';
                buffer.element = addMessage(`${prefix}: ${buffer.text}`, role);
            }
            
            // Set timer to finalize the message
            buffer.timer = setTimeout(() => {
                buffer.text = '';
                buffer.element = null;
                buffer.timer = null;
            }, TRANSCRIPT_BUFFER_DELAY);
        }
        
        function clearTranscriptBuffers() {
            // Clear all buffers and timers
            for (let role in transcriptBuffer) {
                if (transcriptBuffer[role].timer) {
                    clearTimeout(transcriptBuffer[role].timer);
                }
                transcriptBuffer[role] = { text: '', timer: null, element: null };
            }
        }
    
        function filterEvents() {
            const filterInput = document.getElementById('eventFilter');
            const filterText = filterInput.value.toLowerCase();
            const events = document.querySelectorAll('#events .event');
            
            events.forEach(event => {
                const eventText = event.textContent.toLowerCase();
                if (eventText.includes(filterText)) {
                    event.classList.remove('hidden');
                } else {
                    event.classList.add('hidden');
                }
            });
        }
    
        function addMessage(content, type) {
            const messages = document.getElementById('messages');
            const message = document.createElement('div');
            message.className = 'message ' + type;
            message.textContent = content;
            messages.appendChild(message);
            messages.scrollTop = messages.scrollHeight;
            return message;
        }
        
        function addEvent(direction, type, data) {
            const events = document.getElementById('events');
            const event = document.createElement('div');
            event.className = 'event ' + direction;
            
            const time = new Date().toLocaleTimeString();
            const arrow = direction === 'sent' ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';
            const dataStr = typeof data === 'object' ? JSON.stringify(data, null, 2) : data;
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'event-time';
            timeDiv.textContent = `${time} ${arrow}`;

            const typeDiv = document.createElement('div');
            typeDiv.className = 'event-type';
            typeDiv.textContent = type;

            const dataDiv = document.createElement('div');
            dataDiv.className = 'event-data';
            dataDiv.textContent = dataStr;

            event.appendChild(timeDiv);
            event.appendChild(typeDiv);
            event.appendChild(dataDiv);
            
            events.appendChild(event);
            events.scrollTop = events.scrollHeight;
        }
    
        function updateStatus(connected, recording = false) {
            const status = document.getElementById('status');
            const toggleBtn = document.getElementById('toggleBtn');
            const textInput = document.getElementById('textInput');
            const sendBtn = document.getElementById('sendBtn');
            
            if (connected) {
                status.textContent = recording ? 'üî¥ Recording' : 'üü¢ Connected';
                status.className = 'connected';
                toggleBtn.textContent = 'üõë End Conversation';
                toggleBtn.className = 'connected';
                toggleBtn.disabled = false;
                textInput.disabled = false;
                sendBtn.disabled = false;
            } else {
                status.textContent = '‚ö´ Disconnected';
                status.className = 'disconnected';
                toggleBtn.textContent = 'üöÄ Start Conversation';
                toggleBtn.className = '';
                toggleBtn.disabled = false;
                textInput.disabled = true;
                sendBtn.disabled = true;
            }
        }
        
        function toggleConnection() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                disconnect();
            } else {
                connect();
            }
        }
        
        function changeVoice() {
            // Only send voice change if session is active
            if (!ws || ws.readyState !== WebSocket.OPEN || !sessionStarted) {
                return;
            }
            
            const selectedVoice = document.getElementById('voiceSelect').value;
            const voiceLabel = document.getElementById('voiceSelect').selectedOptions[0].text;
            
            // Send a new promptStart with updated voiceId
            const promptStart = {
                event: {
                    promptStart: {
                        promptName: promptName,
                        textOutputConfiguration: {
                            mediaType: "text/plain"
                        },
                        audioOutputConfiguration: {
                            mediaType: "audio/lpcm",
                            sampleRateHertz: 24000,
                            sampleSizeBits: 16,
                            channelCount: 1,
                            voiceId: selectedVoice,
                            encoding: "base64",
                            audioType: "SPEECH"
                        },
                        toolUseOutputConfiguration: {
                            mediaType: "application/json"
                        },
                        toolConfiguration: {
                            "tools": [
                                {
                                    "toolSpec": {
                                        "name": "getDateTool",
                                        "description": "get information about the current day",
                                        "inputSchema": {
                                            "json": JSON.stringify({
                                                "type": "object",
                                                "properties": {},
                                                "required": []
                                            })
                                        }
                                    }
                                }
                            ]
                        }
                    }
                }
            };
            
            ws.send(JSON.stringify(promptStart));
            addEvent('sent', 'promptStart (voice change)', promptStart);
            addMessage(`üé§ Voice changed to: ${voiceLabel}`, 'system');
        }
    
        async function playAudioOutput(base64Audio, sampleRate) {
            if (!audioPlaybackContext) {
                audioPlaybackContext = new AudioContext({ sampleRate: sampleRate });
                nextPlayTime = audioPlaybackContext.currentTime;
                console.log('Created new audio context');
            }
            
            if (audioPlaybackContext.state === 'suspended') {
                await audioPlaybackContext.resume();
                console.log('Resumed audio context');
            }
    
            const binaryString = atob(base64Audio);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
    
            const int16Data = new Int16Array(bytes.buffer);
            const float32Data = new Float32Array(int16Data.length);
            for (let i = 0; i < int16Data.length; i++) {
                float32Data[i] = int16Data[i] / 32768.0;
            }
    
            const buffer = audioPlaybackContext.createBuffer(1, float32Data.length, sampleRate);
            buffer.getChannelData(0).set(float32Data);
            
            const currentTime = audioPlaybackContext.currentTime;
            if (nextPlayTime < currentTime) {
                nextPlayTime = currentTime;
            }
            
            const source = audioPlaybackContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioPlaybackContext.destination);
            
            // Track this source for potential interruption
            activeAudioSources.push(source);
            console.log(`Queued audio chunk (${activeAudioSources.length} active sources), duration: ${buffer.duration.toFixed(2)}s, scheduled at: ${nextPlayTime.toFixed(2)}s`);
            
            // Remove from tracking when it ends
            source.onended = () => {
                const index = activeAudioSources.indexOf(source);
                if (index > -1) {
                    activeAudioSources.splice(index, 1);
                    console.log(`Audio chunk ended (${activeAudioSources.length} remaining)`);
                }
            };
            
            source.start(nextPlayTime);
            nextPlayTime += buffer.duration;
        }
        
        function stopAllAudio() {
            console.log('üõë stopAllAudio called - performing barge-in audio cleanup');
            
            // Stop all active audio sources immediately
            let stoppedCount = 0;
            const sourcesToStop = [...activeAudioSources]; // Create a copy to avoid modification during iteration
            
            sourcesToStop.forEach(source => {
                try {
                    source.stop(0); // Stop immediately at time 0
                    source.disconnect(); // Disconnect from destination
                    stoppedCount++;
                } catch (e) {
                    // Source may have already stopped or finished naturally
                    console.debug('Could not stop audio source:', e.message);
                }
            });
            
            console.log(`‚úÖ Stopped ${stoppedCount} audio sources`);
            activeAudioSources = [];
            
            // Close and reset audio context to ensure complete silence
            if (audioPlaybackContext) {
                try {
                    // Close the context to stop all audio immediately
                    audioPlaybackContext.close();
                    console.log('‚úÖ Audio context closed - all audio stopped');
                } catch (e) {
                    console.error('‚ùå Error closing audio context:', e);
                }
                audioPlaybackContext = null;
                nextPlayTime = 0;
            }
            
            console.log('‚úÖ Barge-in complete - ready for new audio');
        }
    
        function generateId(length = 10) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            return Array.from({ length }, () => 
                chars.charAt(Math.floor(Math.random() * chars.length))
            ).join('');
        }
        
        async function connect() {
            // Disable button while connecting
            const toggleBtn = document.getElementById('toggleBtn');
            toggleBtn.disabled = true;
            toggleBtn.textContent = '‚è≥ Starting...';
            
            document.getElementById('messages').textContent = '';
            document.getElementById('events').textContent = '';
            clearTranscriptBuffers();
            isInterrupted = false; // Reset interrupted state
            
            const websocketUrl = document.getElementById('websocketUrl').value.trim();
            
            if (!websocketUrl) {
                addMessage('‚ùå Error: WebSocket URL is required', 'system');
                toggleBtn.disabled = false;
                toggleBtn.textContent = 'üöÄ Start Conversation';
                return;
            }
            
            const displayUrl = websocketUrl.length > 100 ? websocketUrl.substring(0, 100) + '...' : websocketUrl;
            addMessage(`üîó Connecting to: ${displayUrl}`, 'system');
            
            try {
                ws = new WebSocket(websocketUrl);
                
                ws.onerror = (error) => {
                    addMessage(`‚ùå WebSocket error: ${error.message || 'Connection failed'}`, 'system');
                    console.error('WebSocket error:', error);
                    const toggleBtn = document.getElementById('toggleBtn');
                    toggleBtn.disabled = false;
                    toggleBtn.textContent = 'üöÄ Start Conversation';
                    updateStatus(false);
                };
            
                ws.onopen = async () => {
                    addMessage('‚úÖ Connected to Nova Sonic', 'system');
                    updateStatus(true);
                    
                    // Initialize session
                    promptName = 'prompt_' + generateId();
                    audioContentName = 'audio_' + generateId();
                    textContentName = 'text_' + generateId();
                    
                    // Send session start
                    const sessionStart = {
                        event: {
                            sessionStart: {
                                inferenceConfiguration: {
                                    maxTokens: 1024,
                                    topP: 0.95,
                                    temperature: 0.7
                                }
                            }
                        }
                    };
                    ws.send(JSON.stringify(sessionStart));
                    addEvent('sent', 'sessionStart', sessionStart);
                    
                    // Mark session as started
                    sessionStarted = true;
                    
                    // Wait a bit for server to process sessionStart
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Get selected voice
                    const selectedVoice = document.getElementById('voiceSelect').value;
                    
                    // Send prompt start
                    const promptStart = {
                        event: {
                            promptStart: {
                                promptName: promptName,
                                textOutputConfiguration: {
                                    mediaType: "text/plain"
                                },
                                audioOutputConfiguration: {
                                    mediaType: "audio/lpcm",
                                    sampleRateHertz: 24000,
                                    sampleSizeBits: 16,
                                    channelCount: 1,
                                    voiceId: selectedVoice,
                                    encoding: "base64",
                                    audioType: "SPEECH"
                                },
                                toolUseOutputConfiguration: {
                                    mediaType: "application/json"
                                },
                                toolConfiguration: {
                                    "tools": [
                                        {
                                            "toolSpec": {
                                                "name": "getDateTool",
                                                "description": "get information about the current day",
                                                "inputSchema": {
                                                    "json": JSON.stringify({
                                                        "type": "object",
                                                        "properties": {},
                                                        "required": []
                                                    })
                                                }
                                            }
                                        }
                                    ]
                                }
                            }
                        }
                    };
                    ws.send(JSON.stringify(promptStart));
                    addEvent('sent', 'promptStart', promptStart);
                    
                    // Send system prompt
                    const systemContentStart = {
                        event: {
                            contentStart: {
                                promptName: promptName,
                                contentName: textContentName,
                                type: "TEXT",
                                interactive: false,
                                role: "SYSTEM",
                                textInputConfiguration: {
                                    mediaType: "text/plain"
                                }
                            }
                        }
                    };
                    ws.send(JSON.stringify(systemContentStart));
                    addEvent('sent', 'contentStart (TEXT)', systemContentStart);
                    
                    const textInput = {
                        event: {
                            textInput: {
                                promptName: promptName,
                                contentName: textContentName,
                                content: "You are a friendly assistant. Keep your responses short, generally two or three sentences."
                            }
                        }
                    };
                    ws.send(JSON.stringify(textInput));
                    addEvent('sent', 'textInput', textInput);
                    
                    const systemContentEnd = {
                        event: {
                            contentEnd: {
                                promptName: promptName,
                                contentName: textContentName
                            }
                        }
                    };
                    ws.send(JSON.stringify(systemContentEnd));
                    addEvent('sent', 'contentEnd', systemContentEnd);
                    
                    // Start audio content
                    const audioContentStart = {
                        event: {
                            contentStart: {
                                promptName: promptName,
                                contentName: audioContentName,
                                type: "AUDIO",
                                interactive: true,
                                role: "USER",
                                audioInputConfiguration: {
                                    mediaType: "audio/lpcm",
                                    sampleRateHertz: 16000,
                                    sampleSizeBits: 16,
                                    channelCount: 1,
                                    audioType: "SPEECH",
                                    encoding: "base64"
                                }
                            }
                        }
                    };
                    ws.send(JSON.stringify(audioContentStart));
                    addEvent('sent', 'contentStart (AUDIO)', audioContentStart);
                    
                    // Wait a bit for server to process all setup events
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    // Start recording
                    await startRecording();
                };
            
                ws.onmessage = async (event) => {
                    const data = JSON.parse(event.data);
                    
                    if (!data.event) return;
                    
                    const eventType = Object.keys(data.event)[0];
                    const eventData = data.event[eventType];
                    
                    // EVENT FORMAT NOTES:
                    // Sonic uses nested event structure: { event: { eventType: { ...data } } }
                    // Strands uses flat structure: { type: 'event_type', ...data }
                    // 
                    // BARGE-IN (Interruption) Handling:
                    // - Sonic: contentEnd event with stopReason='INTERRUPTION'
                    // - Strands: dedicated 'bidi_interruption' event
                    // Both trigger the same behavior: stop audio, clear buffers, show message
                    
                    // Log received events (truncate audio)
                    if (eventType === 'audioOutput') {
                        addEvent('received', eventType, { ...eventData, content: `[${eventData.content?.length || 0} bytes]` });
                    } else {
                        addEvent('received', eventType, data);
                    }
                    
                    switch (eventType) {
                        case 'contentEnd':
                            // Log all contentEnd events for debugging
                            const stopReason = eventData.stopReason || 'NONE';
                            console.log('contentEnd received:', {
                                type: eventData.type,
                                role: eventData.role,
                                stopReason: stopReason,
                                contentName: eventData.contentName,
                                rawEventData: eventData
                            });
                            
                            // Handle interruption (barge-in) - check case-insensitively
                            // This is triggered when user speaks while assistant is responding
                            // Note: stopReason can be 'INTERRUPTED' or 'INTERRUPTION' depending on the event
                            const stopReasonUpper = stopReason.toUpperCase();
                            if (stopReasonUpper === 'INTERRUPTED' || stopReasonUpper === 'INTERRUPTION') {
                                console.log('‚úÖ INTERRUPTION detected via contentEnd - performing barge-in');
                                isInterrupted = true;
                                
                                // Add visual feedback in conversation panel
                                addMessage('üö´ [Interrupted - Barge-in detected]', 'system');
                                
                                // Clear any buffered transcripts
                                clearTranscriptBuffers();
                                
                                // Stop all audio playback immediately
                                stopAllAudio();
                            } else {
                                console.log(`No interruption - stopReason is: "${stopReason}"`);
                            }
                            
                            // Reset generation stage when content ends
                            currentGenerationStage = null;
                            break;
                        case 'contentStart':
                            // Track generation stage from additionalModelFields
                            if (eventData.additionalModelFields) {
                                try {
                                    const modelFields = JSON.parse(eventData.additionalModelFields);
                                    currentGenerationStage = modelFields.generationStage;
                                } catch (e) {
                                    console.error('Failed to parse additionalModelFields:', e);
                                }
                            }
                            
                            // Reset interrupted flag when new content starts
                            if (eventData.role === 'ASSISTANT' && eventData.type === 'AUDIO') {
                                isInterrupted = false;
                                console.log('New assistant audio content starting - reset interrupted flag');
                            }
                            break;
                        case 'interruption':
                            // Handle explicit interruption event (alternative format)
                            // Note: Sonic typically uses contentEnd with stopReason='INTERRUPTION'
                            // but this handler is kept for compatibility if server sends explicit interruption events
                            console.log('‚ö†Ô∏è Explicit interruption event received (alternative format)');
                            isInterrupted = true;
                            addMessage('üö´ [Interrupted - Barge-in detected]', 'system');
                            clearTranscriptBuffers();
                            stopAllAudio();
                            break;
                        case 'audioOutput':
                            // Skip audio playback if we're in an interrupted state
                            if (isInterrupted) {
                                console.log('Skipping audio playback - interrupted state');
                                break;
                            }
                            await playAudioOutput(eventData.content, 24000);
                            break;
                        case 'textOutput':
                            // Display textOutput based on role and generationStage:
                            // - ASSISTANT: only when generationStage is SPECULATIVE
                            // - USER: only when generationStage is FINAL
                            const role = (eventData.role || 'ASSISTANT').toLowerCase();
                            const shouldDisplay = 
                                (role === 'assistant' && currentGenerationStage === 'SPECULATIVE') ||
                                (role === 'user' && currentGenerationStage === 'FINAL');
                            
                            if (shouldDisplay) {
                                // Use buffered transcript handling for smoother display
                                handleBufferedTranscript(role, eventData.content);
                            }
                            break;
                        case 'toolUse':
                            addMessage(`üîß Tool: ${eventData.toolName}`, 'tool');
                            break;
                        case 'toolResult':
                            // Display tool result in conversation
                            let resultContent = eventData.content;
                            try {
                                // Try to parse and pretty-print JSON content
                                const parsed = JSON.parse(resultContent);
                                resultContent = JSON.stringify(parsed, null, 2);
                            } catch (e) {
                                // Not JSON, use as-is
                            }
                            addMessage(`üìä Tool Result:\n${resultContent}`, 'tool');
                            break;
                    }
                };
            
                ws.onclose = (event) => {
                    let reason = 'Unknown reason';
                    let details = '';
                    
                    // Decode close code
                    if (event.code === 1000) {
                        reason = 'Normal closure';
                    } else if (event.code === 1001) {
                        reason = 'Going away (browser navigating away or server shutting down)';
                    } else if (event.code === 1002) {
                        reason = 'Protocol error';
                    } else if (event.code === 1003) {
                        reason = 'Unsupported data';
                    } else if (event.code === 1006) {
                        reason = 'Abnormal closure (no close frame received)';
                        details = ' - This often indicates network issues, server crash, or expired presigned URL';
                    } else if (event.code === 1007) {
                        reason = 'Invalid frame payload data';
                    } else if (event.code === 1008) {
                        reason = 'Policy violation';
                    } else if (event.code === 1009) {
                        reason = 'Message too big';
                    } else if (event.code === 1010) {
                        reason = 'Missing extension';
                    } else if (event.code === 1011) {
                        reason = 'Internal server error';
                    } else if (event.code === 1015) {
                        reason = 'TLS handshake failure';
                    } else {
                        reason = `Unknown code: ${event.code}`;
                    }
                    
                    const closeReason = event.reason ? ` - ${event.reason}` : '';
                    const wasClean = event.wasClean ? 'Clean' : 'Unclean';
                    
                    console.log(`WebSocket closed: Code=${event.code}, Reason=${reason}, Clean=${event.wasClean}`);
                    console.log(`Event details:`, event);
                    
                    addMessage(`‚ùå Disconnected (${wasClean})`, 'system');
                    addMessage(`üìã Code ${event.code}: ${reason}${closeReason}${details}`, 'system');
                    addEvent('received', 'close', {
                        code: event.code,
                        reason: reason,
                        wasClean: event.wasClean,
                        customReason: event.reason || 'none'
                    });
                    
                    updateStatus(false);
                    clearTranscriptBuffers();
                    if (isRecording) stopRecording();
                    stopAllAudio();
                };
            } catch (error) {
                addMessage(`‚ùå Failed to connect: ${error.message}`, 'system');
                console.error('Connection error:', error);
                const toggleBtn = document.getElementById('toggleBtn');
                toggleBtn.disabled = false;
                toggleBtn.textContent = 'üöÄ Start Conversation';
                updateStatus(false);
            }
        }
    
        function disconnect() {
            if (isRecording) stopRecording();
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                // Send content end for audio
                const audioContentEnd = {
                    event: {
                        contentEnd: {
                            promptName: promptName,
                            contentName: audioContentName
                        }
                    }
                };
                ws.send(JSON.stringify(audioContentEnd));
                addEvent('sent', 'contentEnd', audioContentEnd);
                
                // Send prompt end
                const promptEnd = {
                    event: {
                        promptEnd: {
                            promptName: promptName
                        }
                    }
                };
                ws.send(JSON.stringify(promptEnd));
                addEvent('sent', 'promptEnd', promptEnd);
                
                // Send session end
                const sessionEnd = {
                    event: {
                        sessionEnd: {}
                    }
                };
                ws.send(JSON.stringify(sessionEnd));
                addEvent('sent', 'sessionEnd', sessionEnd);
            }
            
            if (ws) ws.close();
        }


    
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { channelCount: 1, echoCancellation: true, noiseSuppression: true } 
                });
                
                audioContext = new AudioContext();
                const source = audioContext.createMediaStreamSource(stream);
                const processor = audioContext.createScriptProcessor(4096, 1, 1);
                
                let audioChunkCount = 0;
                processor.onaudioprocess = (e) => {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        
                        // Downsample to 16kHz
                        const downsampleRatio = audioContext.sampleRate / 16000;
                        const outputLength = Math.floor(inputData.length / downsampleRatio);
                        const int16Data = new Int16Array(outputLength);
                        
                        for (let i = 0; i < outputLength; i++) {
                            const sourceIndex = Math.floor(i * downsampleRatio);
                            int16Data[i] = Math.max(-32768, Math.min(32767, inputData[sourceIndex] * 32768));
                        }
                        
                        const bytes = new Uint8Array(int16Data.buffer);
                        let binary = '';
                        for (let i = 0; i < bytes.length; i++) {
                            binary += String.fromCharCode(bytes[i]);
                        }
                        const base64Audio = btoa(binary);
                        
                        const payload = {
                            event: {
                                audioInput: {
                                    promptName: promptName,
                                    contentName: audioContentName,
                                    content: base64Audio
                                }
                            }
                        };
                        ws.send(JSON.stringify(payload));
                        
                        // Log audio chunks less frequently with truncated content
                        audioChunkCount++;
                        if (audioChunkCount % 10 === 0) {
                            // Truncate audio content for display
                            const truncatedPayload = {
                                event: {
                                    audioInput: {
                                        promptName: promptName,
                                        contentName: audioContentName,
                                        content: `[${base64Audio.length} bytes]`
                                    }
                                }
                            };
                            addEvent('sent', 'audioInput', truncatedPayload);
                        }
                    }
                };
                
                source.connect(processor);
                processor.connect(audioContext.destination);
                
                isRecording = true;
                updateStatus(true, true);
                addMessage('üéôÔ∏è Session started - speak now', 'system');
            } catch (err) {
                addMessage('‚ùå Microphone access denied: ' + err.message, 'system');
            }
        }
        
        function stopRecording() {
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            isRecording = false;
            addMessage('‚èπÔ∏è Session stopped', 'system');
        }

        function sendTextMessage() {
            const textInput = document.getElementById('textInput');
            const message = textInput.value.trim();
            
            if (!message || !ws || ws.readyState !== WebSocket.OPEN || !sessionStarted) {
                return;
            }
            
            // Generate a new content name for this text message
            const newTextContentName = 'text_' + generateId();
            
            // Send contentStart event
            const contentStart = {
                event: {
                    contentStart: {
                        promptName: promptName,
                        contentName: newTextContentName,
                        role: "USER",
                        type: "TEXT",
                        interactive: true,
                        textInputConfiguration: {
                            mediaType: "text/plain"
                        }
                    }
                }
            };
            ws.send(JSON.stringify(contentStart));
            addEvent('sent', 'contentStart (TEXT)', contentStart);
            
            // Send textInput event
            const textInputEvent = {
                event: {
                    textInput: {
                        promptName: promptName,
                        contentName: newTextContentName,
                        content: message
                    }
                }
            };
            ws.send(JSON.stringify(textInputEvent));
            addEvent('sent', 'textInput', textInputEvent);
            
            // Send contentEnd event
            const contentEnd = {
                event: {
                    contentEnd: {
                        promptName: promptName,
                        contentName: newTextContentName
                    }
                }
            };
            ws.send(JSON.stringify(contentEnd));
            addEvent('sent', 'contentEnd', contentEnd);
            
            // Add message to conversation
            addMessage(`üí¨ You: ${message}`, 'user');
            
            // Clear input
            textInput.value = '';
        }

        // Add Enter key handler for text input
        document.addEventListener('DOMContentLoaded', function() {
            const textInput = document.getElementById('textInput');
            textInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendTextMessage();
                }
            });
        });

    </script>
</body>
</html>
